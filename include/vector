#pragma once

#include <utility>
#include <memory>
#include <iterator>

extern "C" {
    #include <stdlib.h>
    #include <string.h>
}

namespace std {

template<typename T>
class vector {
public:
    using value_type = T;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using reference = T&;
    using const_reference = const T&;
    using pointer = T*;
    using const_pointer = const T*;
    using iterator = T*;
    using const_iterator = const T*;
    
private:
    T* data_;
    size_type size_;
    size_type capacity_;
    
    void destroy_elements() {
        for (size_type i = 0; i < size_; ++i) {
            data_[i].~T();
        }
    }
    
    void reserve_internal(size_type new_cap) {
        if (new_cap <= capacity_) return;
        
        T* new_data = static_cast<T*>(::operator new(new_cap * sizeof(T)));
        
        // Move construct elements
        for (size_type i = 0; i < size_; ++i) {
            new (&new_data[i]) T(move(data_[i]));
            data_[i].~T();
        }
        
        if (data_) {
            ::operator delete(data_);
        }
        
        data_ = new_data;
        capacity_ = new_cap;
    }
    
public:
    // Constructors
    vector() noexcept : data_(nullptr), size_(0), capacity_(0) {}
    
    explicit vector(size_type count) : data_(nullptr), size_(0), capacity_(0) {
        reserve(count);
        for (size_type i = 0; i < count; ++i) {
            new (&data_[i]) T();
        }
        size_ = count;
    }
    
    vector(size_type count, const T& value) : data_(nullptr), size_(0), capacity_(0) {
        reserve(count);
        for (size_type i = 0; i < count; ++i) {
            new (&data_[i]) T(value);
        }
        size_ = count;
    }
    
    vector(const vector& other) : data_(nullptr), size_(0), capacity_(0) {
        reserve(other.size_);
        for (size_type i = 0; i < other.size_; ++i) {
            new (&data_[i]) T(other.data_[i]);
        }
        size_ = other.size_;
    }
    
    vector(vector&& other) noexcept 
        : data_(other.data_), size_(other.size_), capacity_(other.capacity_) {
        other.data_ = nullptr;
        other.size_ = 0;
        other.capacity_ = 0;
    }
    
    vector(initializer_list<T> init) : data_(nullptr), size_(0), capacity_(0) {
        reserve(init.size());
        for (const auto& item : init) {
            new (&data_[size_++]) T(item);
        }
    }
    
    ~vector() {
        if (data_) {
            destroy_elements();
            ::operator delete(data_);
        }
    }
    
    // Assignment
    vector& operator=(const vector& other) {
        if (this != &other) {
            clear();
            reserve(other.size_);
            for (size_type i = 0; i < other.size_; ++i) {
                new (&data_[i]) T(other.data_[i]);
            }
            size_ = other.size_;
        }
        return *this;
    }
    
    vector& operator=(vector&& other) noexcept {
        if (this != &other) {
            if (data_) {
                destroy_elements();
                ::operator delete(data_);
            }
            
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            
            other.data_ = nullptr;
            other.size_ = 0;
            other.capacity_ = 0;
        }
        return *this;
    }
    
    vector& operator=(initializer_list<T> ilist) {
        clear();
        reserve(ilist.size());
        for (const auto& item : ilist) {
            new (&data_[size_++]) T(item);
        }
        return *this;
    }
    
    void assign(size_type count, const T& value) {
        clear();
        reserve(count);
        for (size_type i = 0; i < count; ++i) {
            new (&data_[i]) T(value);
        }
        size_ = count;
    }
    
    // Element access
    reference at(size_type pos) {
        if (pos >= size_) __builtin_trap();
        return data_[pos];
    }
    
    const_reference at(size_type pos) const {
        if (pos >= size_) __builtin_trap();
        return data_[pos];
    }
    
    reference operator[](size_type pos) { return data_[pos]; }
    const_reference operator[](size_type pos) const { return data_[pos]; }
    
    reference front() { return data_[0]; }
    const_reference front() const { return data_[0]; }
    
    reference back() { return data_[size_ - 1]; }
    const_reference back() const { return data_[size_ - 1]; }
    
    T* data() noexcept { return data_; }
    const T* data() const noexcept { return data_; }
    
    // Iterators
    iterator begin() noexcept { return data_; }
    const_iterator begin() const noexcept { return data_; }
    const_iterator cbegin() const noexcept { return data_; }
    
    iterator end() noexcept { return data_ + size_; }
    const_iterator end() const noexcept { return data_ + size_; }
    const_iterator cend() const noexcept { return data_ + size_; }
    
    // Capacity
    [[nodiscard]] bool empty() const noexcept { return size_ == 0; }
    size_type size() const noexcept { return size_; }
    size_type max_size() const noexcept { return static_cast<size_type>(-1) / sizeof(T); }
    size_type capacity() const noexcept { return capacity_; }
    
    void reserve(size_type new_cap) {
        if (new_cap > capacity_) {
            reserve_internal(new_cap);
        }
    }
    
    void shrink_to_fit() {
        if (capacity_ > size_) {
            if (size_ == 0) {
                ::operator delete(data_);
                data_ = nullptr;
                capacity_ = 0;
            } else {
                T* new_data = static_cast<T*>(::operator new(size_ * sizeof(T)));
                for (size_type i = 0; i < size_; ++i) {
                    new (&new_data[i]) T(move(data_[i]));
                    data_[i].~T();
                }
                ::operator delete(data_);
                data_ = new_data;
                capacity_ = size_;
            }
        }
    }
    
    // Modifiers
    void clear() noexcept {
        destroy_elements();
        size_ = 0;
    }
    
    iterator insert(const_iterator pos, const T& value) {
        size_type index = pos - data_;
        if (size_ >= capacity_) {
            reserve_internal(capacity_ == 0 ? 8 : capacity_ * 2);
        }
        
        // Move elements after insertion point
        for (size_type i = size_; i > index; --i) {
            new (&data_[i]) T(move(data_[i - 1]));
            data_[i - 1].~T();
        }
        
        new (&data_[index]) T(value);
        ++size_;
        return data_ + index;
    }
    
    iterator insert(const_iterator pos, T&& value) {
        size_type index = pos - data_;
        if (size_ >= capacity_) {
            reserve_internal(capacity_ == 0 ? 8 : capacity_ * 2);
        }
        
        for (size_type i = size_; i > index; --i) {
            new (&data_[i]) T(move(data_[i - 1]));
            data_[i - 1].~T();
        }
        
        new (&data_[index]) T(move(value));
        ++size_;
        return data_ + index;
    }
    
    iterator insert(const_iterator pos, size_type count, const T& value) {
        size_type index = pos - data_;
        if (size_ + count > capacity_) {
            reserve_internal(size_ + count);
        }
        
        for (size_type i = size_ + count - 1; i >= index + count; --i) {
            new (&data_[i]) T(move(data_[i - count]));
            data_[i - count].~T();
        }
        
        for (size_type i = 0; i < count; ++i) {
            new (&data_[index + i]) T(value);
        }
        
        size_ += count;
        return data_ + index;
    }
    
    template<typename... Args>
    iterator emplace(const_iterator pos, Args&&... args) {
        size_type index = pos - data_;
        if (size_ >= capacity_) {
            reserve_internal(capacity_ == 0 ? 8 : capacity_ * 2);
        }
        
        for (size_type i = size_; i > index; --i) {
            new (&data_[i]) T(move(data_[i - 1]));
            data_[i - 1].~T();
        }
        
        new (&data_[index]) T(forward<Args>(args)...);
        ++size_;
        return data_ + index;
    }
    
    iterator erase(const_iterator pos) {
        size_type index = pos - data_;
        data_[index].~T();
        
        for (size_type i = index; i < size_ - 1; ++i) {
            new (&data_[i]) T(move(data_[i + 1]));
            data_[i + 1].~T();
        }
        
        --size_;
        return data_ + index;
    }
    
    iterator erase(const_iterator first, const_iterator last) {
        size_type start = first - data_;
        size_type count = last - first;
        
        for (size_type i = start; i < start + count; ++i) {
            data_[i].~T();
        }
        
        for (size_type i = start; i < size_ - count; ++i) {
            new (&data_[i]) T(move(data_[i + count]));
            data_[i + count].~T();
        }
        
        size_ -= count;
        return data_ + start;
    }
    
    void push_back(const T& value) {
        if (size_ >= capacity_) {
            reserve_internal(capacity_ == 0 ? 8 : capacity_ * 2);
        }
        new (&data_[size_++]) T(value);
    }
    
    void push_back(T&& value) {
        if (size_ >= capacity_) {
            reserve_internal(capacity_ == 0 ? 8 : capacity_ * 2);
        }
        new (&data_[size_++]) T(move(value));
    }
    
    template<typename... Args>
    reference emplace_back(Args&&... args) {
        if (size_ >= capacity_) {
            reserve_internal(capacity_ == 0 ? 8 : capacity_ * 2);
        }
        new (&data_[size_]) T(forward<Args>(args)...);
        return data_[size_++];
    }
    
    void pop_back() {
        if (size_ > 0) {
            data_[--size_].~T();
        }
    }
    
    void resize(size_type count) {
        if (count < size_) {
            for (size_type i = count; i < size_; ++i) {
                data_[i].~T();
            }
        } else if (count > size_) {
            reserve(count);
            for (size_type i = size_; i < count; ++i) {
                new (&data_[i]) T();
            }
        }
        size_ = count;
    }
    
    void resize(size_type count, const T& value) {
        if (count < size_) {
            for (size_type i = count; i < size_; ++i) {
                data_[i].~T();
            }
        } else if (count > size_) {
            reserve(count);
            for (size_type i = size_; i < count; ++i) {
                new (&data_[i]) T(value);
            }
        }
        size_ = count;
    }
    
    void swap(vector& other) noexcept {
        T* tmp_data = data_;
        size_type tmp_size = size_;
        size_type tmp_capacity = capacity_;
        
        data_ = other.data_;
        size_ = other.size_;
        capacity_ = other.capacity_;
        
        other.data_ = tmp_data;
        other.size_ = tmp_size;
        other.capacity_ = tmp_capacity;
    }
};

// Non-member functions
template<typename T>
bool operator==(const vector<T>& lhs, const vector<T>& rhs) {
    if (lhs.size() != rhs.size()) return false;
    for (size_t i = 0; i < lhs.size(); ++i) {
        if (!(lhs[i] == rhs[i])) return false;
    }
    return true;
}

template<typename T>
bool operator!=(const vector<T>& lhs, const vector<T>& rhs) {
    return !(lhs == rhs);
}

template<typename T>
bool operator<(const vector<T>& lhs, const vector<T>& rhs) {
    size_t min_size = lhs.size() < rhs.size() ? lhs.size() : rhs.size();
    for (size_t i = 0; i < min_size; ++i) {
        if (lhs[i] < rhs[i]) return true;
        if (rhs[i] < lhs[i]) return false;
    }
    return lhs.size() < rhs.size();
}

template<typename T>
bool operator<=(const vector<T>& lhs, const vector<T>& rhs) {
    return !(rhs < lhs);
}

template<typename T>
bool operator>(const vector<T>& lhs, const vector<T>& rhs) {
    return rhs < lhs;
}

template<typename T>
bool operator>=(const vector<T>& lhs, const vector<T>& rhs) {
    return !(lhs < rhs);
}

template<typename T>
void swap(vector<T>& lhs, vector<T>& rhs) noexcept {
    lhs.swap(rhs);
}

}
